<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="20700" uniqueCount="54"><si><t xml:space="preserve">longitude</t></si><si><t xml:space="preserve">latitude</t></si><si><t xml:space="preserve">housing_median_age</t></si><si><t xml:space="preserve">total_rooms</t></si><si><t xml:space="preserve">total_bedrooms</t></si><si><t xml:space="preserve">population</t></si><si><t xml:space="preserve">households</t></si><si><t xml:space="preserve">median_income</t></si><si><t xml:space="preserve">median_house_value</t></si><si><t xml:space="preserve">ocean_proximity</t></si><si><t xml:space="preserve">NEAR BAY</t></si><si><t xml:space="preserve">&lt;1H OCEAN</t></si><si><t xml:space="preserve">INLAND</t></si><si><t xml:space="preserve">NEAR OCEAN</t></si><si><t xml:space="preserve">ISLAND</t></si><si><t xml:space="preserve">0. to avoid replacing blank cells with 0s, let us fill in blanks using the string “$BLANK”</t></si><si><t xml:space="preserve">1. We shuffle by adding a random index (column A) using Sheet &gt; Fill Cells &gt; Fill Random number. Then we sort by column A ascending.</t></si><si><t xml:space="preserve">index</t></si><si><t xml:space="preserve">2. Now we split into testing data and training data (discarding the unnecessary random index column).</t></si><si><t xml:space="preserve">Testing data</t></si><si><t xml:space="preserve">Total count</t></si><si><t xml:space="preserve">Test size</t></si><si><t xml:space="preserve">Test count</t></si><si><t xml:space="preserve">First test row</t></si><si><t xml:space="preserve">Last test row</t></si><si><t xml:space="preserve">Training data</t></si><si><t xml:space="preserve">3. We categorize the features of the training data. The dependent feature is “median_house_value“. We further categorize the independent features as numerical or categorical.</t></si><si><t xml:space="preserve">numerical</t></si><si><t xml:space="preserve">categorical</t></si><si><t xml:space="preserve">dependent</t></si><si><t xml:space="preserve">4.0 We describe numerical data statistically.</t></si><si><t xml:space="preserve">percentile</t></si><si><t xml:space="preserve">count</t></si><si><t xml:space="preserve">mean</t></si><si><t xml:space="preserve">stdev</t></si><si><t xml:space="preserve">min</t></si><si><t xml:space="preserve">low quartile</t></si><si><t xml:space="preserve">median</t></si><si><t xml:space="preserve">upper quartile</t></si><si><t xml:space="preserve">max</t></si><si><t xml:space="preserve">IQR</t></si><si><t xml:space="preserve">range</t></si><si><t xml:space="preserve">4.1 Minimal non-zero central interpercentile range:&#10;For each feature, starting at the lower percentile with percent p = 25% and the matching upper percentile with percent (1 – p), we find the first non-zero range.&#10;Then scale by dividing by (2 – 4p).&#10;The interquartile range is referenced for comparison.</t></si><si><t xml:space="preserve">percent</t></si><si><t xml:space="preserve">lower percentile</t></si><si><t xml:space="preserve">upper percentile</t></si><si><t xml:space="preserve">nonzero range</t></si><si><t xml:space="preserve">inter percentile range</t></si><si><t xml:space="preserve">scaled</t></si><si><t xml:space="preserve">ref IQR</t></si><si><t xml:space="preserve">4.2 for the number of histogram bins, we use the Freedman-Diaconis’s choice formula</t></si><si><t xml:space="preserve">scaled IPR</t></si><si><t xml:space="preserve">bin width</t></si><si><t xml:space="preserve"># bins</t></si></sst>