<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="16765" uniqueCount="47"><si><t xml:space="preserve">Every change we make to the training data while cleaning it, must be made to the testing data as&#10;well and in the same order, so we record every change in this summary.</t></si><si><t xml:space="preserve">empty replacement</t></si><si><t xml:space="preserve">&quot;&quot;</t></si><si><t xml:space="preserve">#N/A</t></si><si><t xml:space="preserve">count categories</t></si><si><t xml:space="preserve">encoding</t></si><si><t xml:space="preserve">change</t></si><si><t xml:space="preserve">param name</t></si><si><t xml:space="preserve">param value</t></si><si><t xml:space="preserve">ocean_proximity</t></si><si><t xml:space="preserve">&lt;1H OCEAN</t></si><si><t xml:space="preserve">INLAND</t></si><si><t xml:space="preserve">ISLAND</t></si><si><t xml:space="preserve">NEAR BAY</t></si><si><t xml:space="preserve">xy split</t></si><si><t xml:space="preserve">label</t></si><si><t xml:space="preserve">median_house_value</t></si><si><t xml:space="preserve">one hot encoding</t></si><si><t xml:space="preserve">see I3:M10</t></si><si><t xml:space="preserve">from &quot;categorize features&quot;</t></si><si><t xml:space="preserve">NEAR OCEAN</t></si><si><t xml:space="preserve">We copy the data from the &quot;split training&quot; spreadsheet in the &quot;01-split_data.xlsx&quot; workbook.</t></si><si><t xml:space="preserve">longitude</t></si><si><t xml:space="preserve">latitude</t></si><si><t xml:space="preserve">housing_median_age</t></si><si><t xml:space="preserve">total_rooms</t></si><si><t xml:space="preserve">total_bedrooms</t></si><si><t xml:space="preserve">population</t></si><si><t xml:space="preserve">households</t></si><si><t xml:space="preserve">median_income</t></si><si><t xml:space="preserve">Identify the features (independent variables) and label (dependent variable). We are analyzing&#10;longitude, latitude, housing median age, total number of rooms, total number of bedrooms,&#10;population, number of households, median income, and ocean proximity to predict the median&#10;house value. Accordingly, let’s categorize and set apart the features and the label.</t></si><si><t xml:space="preserve">features</t></si><si><t xml:space="preserve">Features may be further categorized as numerical (which uses numbers for values) or categorical data (which &#10;uses names for values). In order to apply a machine learning algorithm, all data must be numerical. The more &#10;general technique to convert from categorical data to convert from categorical to numerical is one-hot&#10;encoding.&#10;&#10;One-hot encoding is performed by transforming the column for that feature into a separate column for each&#10;category in the original feature, which is assigned the value &quot;1&quot; when the new feature matches the original &#10;category or &quot;0&quot; when it does not. Additionally, because for each row, the sum of these features always add up&#10;to 1, they are linearly dependent, so one feature may be omitted as long as it is documented which one. This &#10;feature may always be reconstituted as =(1 – SUM(&lt;other features&gt;)) as needed.&#10;&#10;Categorical data may be divided further yet into ordinal data (which can be formed into a ranking  system) &#10;and nominal data (which cannot be). One-hot encoding is used for nominal data because  it does not enforce&#10;a relationship between the different categories. However, when such a relationship is beneficial, which is the &#10;case for ordinal data, label encoding is used, which keeps the feature as 1 column, but giving each ordinal an &#10;integer value starting at 0.&#10;&#10;In this case, we could benefit better results from label encoding, but I will use one-hot encoding because it &#10;requires more explanation, but is also more general, so we can use it when we are unsure. The trade off is the &#10;positive of removing the risk of introducing rating where there may be none, for the negative of higher &#10;dimensionality (more features features to clean and analyze). So when we are sure if the data is ordinal or &#10;nominal, prefer label encoding for ordinal data and one-hot for nominal data.</t></si><si><t xml:space="preserve">Label encoding is straightforward. Using this example, </t></si><si><t xml:space="preserve">Let’s split the data as numerical, ordinal, nominal.&#10;In this example, ocean proximity is ordinal, but we do not have nominal data. However, we are&#10;treating ocean proximity as nominal and using one-hot encoding for this example.&#10;Let’s find the frequency of each category of ocean_proximity. Since they are &quot;nominal&quot;, the order&#10;of the categories does not matter, and I chose ASCII order. Counting allows us to see we have not&#10;missed any category. Notice how &quot;NEAR OCEAN&quot; is encoded as [0, 0, 0, 0].&#10;&#10;Use COUNTA to count all values (including text) in a range, and =COUNTIF(&lt;range&gt;,&lt;key&gt;) to count all values equal to &lt;key&gt; in the given &lt;range&gt;. Additionally, I added a column before the ocean proximity data for the heads, merged the two columns and hid the former column, allowing me to operate on the data as a whole column (just a nice spreadsheet trick useful for parameters).</t></si><si><t xml:space="preserve">numerical</t></si><si><t xml:space="preserve">ordinal</t></si><si><t xml:space="preserve">multiplicity</t></si><si><t xml:space="preserve">frequency</t></si><si><t xml:space="preserve">all</t></si><si><t xml:space="preserve">total diff</t></si><si><t xml:space="preserve">Now let’s replace the ocean proximity column by using the one-hot encoding from the summary&#10;(which has been copied from the &quot;categorize features&quot; sheet for portability).&#10;We use the =VLOOKUP(&lt;key&gt;,&lt;array&gt;,&lt;# columns&gt;,&lt;range lookup&gt;) function to lookup this&#10;row’s ocean_proximity as &lt;key&gt; on the one-hot encoding table for ocean proximity &lt;array&gt; in the&#10;summary. The &lt;# columns&gt; represents the number of columns in the array, which can be found by&#10;using COLUMNS(&lt;array&gt;), and for &lt;range lookup&gt;, we use 0 for exact matches.&#10;Finally, I use relative column indices for the array because an earlier column will never need to be&#10;searched for in a later column. (For example, you don&apos;t need to search in &quot;INLAND&quot; for &#10;&quot;&lt;1H OCEAN&quot;.</t></si><si><r><rPr><b val="true"/><sz val="10"/><rFont val="Arial"/><family val="2"/><charset val="1"/></rPr><t xml:space="preserve">Example:</t></r><r><rPr><sz val="10"/><rFont val="Arial"/><family val="2"/><charset val="1"/></rPr><t xml:space="preserve"> Let’s prove that ocean_proximity is ordinal and demonstrate label encoding.&#10;To the right, we filter out the longitude and latitude matching each of the ocean_proximity categories.&#10;We can use these to create a scatter plot of each of the datasets representing these categories with&#10;Longitude as x and latitude as y shown below in Fig. 1.&#10;Latitude, longitude and ocean proximity are really just related geographic information systems data,&#10;and Fig. 1 shows this. It’s a map of the state of California with the Pacific ocean bordering its&#10;Western and southern shores.&#10;We can thus produce the label encoding in column B with 0 having the lowest median ocean&#10;proximity and 4 having the highest, giving the order (INLAND, &lt;1H OCEAN, NEAR BAY,&#10;NEAR OCEAN, ISLAND).&#10;The longitude counts from the categories on this sheet are compared with those from the&#10;&quot;categorize features&quot; one-hot encoding table to ensure that all data points have been plotted.&#10;For label encoding, we simply would exchange the values in column A with those in column B in the&#10;original data. However, let’s continue using one-hot encoding.</t></r></si><si><t xml:space="preserve">label count</t></si><si><t xml:space="preserve">one-hot count</t></si><si><t xml:space="preserve">diff</t></si><si><t xml:space="preserve">Let’s analyze the distribution of the data visually. In preparation, let’s find the ranges for each variable and decide appropriate bin sizes for a histogram.</t></si></sst>